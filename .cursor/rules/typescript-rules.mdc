---
description: TypeScript frontend development rules for PSX Analytics Platform
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx", "**/package.json", "**/tsconfig.json"]
alwaysApply: false
---

# TypeScript Frontend Development Rules - PSX Analytics Platform

## TypeScript Version & Tools
- **TypeScript**: 5.0+ (latest stable)
- **React**: 18+ with hooks and functional components
- **Build Tool**: Vite for fast development and building
- **Package Manager**: npm or yarn (consistent across team)
- **Code Generation**: OpenAPI codegen for API types and clients

## Project Structure
```
frontend/
├── src/
│   ├── components/         # Reusable UI components
│   │   ├── common/        # Generic components (Button, Input, etc.)
│   │   ├── charts/        # Chart components (TradingView, etc.)
│   │   ├── forms/         # Form components
│   │   └── layout/        # Layout components (Header, Sidebar, etc.)
│   ├── pages/             # Page components
│   │   ├── auth/          # Authentication pages
│   │   ├── dashboard/     # Dashboard pages
│   │   ├── market/        # Market data pages
│   │   ├── portfolio/     # Portfolio management pages
│   │   └── analytics/     # Analytics pages
│   ├── hooks/             # Custom React hooks
│   ├── services/          # API services and external integrations
│   ├── stores/            # State management (Zustand)
│   ├── types/             # TypeScript type definitions
│   ├── utils/             # Utility functions
│   ├── constants/         # Application constants
│   └── assets/            # Static assets (images, icons, etc.)
├── public/                 # Public assets
├── tests/                  # Test files
│   ├── unit/              # Unit tests
│   ├── integration/       # Integration tests
│   └── e2e/               # End-to-end tests
└── docs/                   # Frontend documentation
```

## TypeScript Coding Standards

### Code Style
- **Strict Mode**: Enable all strict TypeScript options
- **Linting**: ESLint with @typescript-eslint rules
- **Formatting**: Prettier for consistent code formatting
- **Naming**: Follow React and TypeScript conventions
  - `camelCase` for variables and functions
  - `PascalCase` for components and types
  - `UPPER_CASE` for constants
  - `kebab-case` for file names

### Type Safety
```typescript
// Good: Strong typing with no any types
interface User {
  id: number;
  username: string;
  email: string;
  role: UserRole;
  createdAt: Date;
}

type UserRole = 'user' | 'premium' | 'professional' | 'institutional';

// Good: Generic types for reusable components
interface DataTableProps<T> {
  data: T[];
  columns: Column<T>[];
  onRowClick?: (item: T) => void;
  loading?: boolean;
}

// Good: Union types for state management
type AuthState = 
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'authenticated'; user: User }
  | { status: 'error'; message: string };
```

### Component Structure
```typescript
// Good: Functional components with proper typing
interface UserProfileProps {
  userId: number;
  onEdit?: (user: User) => void;
  onDelete?: (userId: number) => void;
}

export const UserProfile: React.FC<UserProfileProps> = ({
  userId,
  onEdit,
  onDelete
}) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchUser(userId);
  }, [userId]);

  const fetchUser = async (id: number) => {
    try {
      setLoading(true);
      const userData = await userService.getUser(id);
      setUser(userData);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch user');
    } finally {
      setLoading(false);
    }
  };

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error} />;
  if (!user) return <NotFound />;

  return (
    <div className="user-profile">
      <h2>{user.username}</h2>
      <p>{user.email}</p>
      <div className="actions">
        {onEdit && <Button onClick={() => onEdit(user)}>Edit</Button>}
        {onDelete && <Button onClick={() => onDelete(user.id)}>Delete</Button>}
      </div>
    </div>
  );
};
```

## React Best Practices

### Hooks Usage
```typescript
// Good: Custom hooks for reusable logic
export const useUser = (userId: number) => {
  const [state, setState] = useState<AuthState>({ status: 'idle' });

  const fetchUser = useCallback(async () => {
    setState({ status: 'loading' });
    try {
      const user = await userService.getUser(userId);
      setState({ status: 'authenticated', user });
    } catch (error) {
      setState({ 
        status: 'error', 
        message: error instanceof Error ? error.message : 'Unknown error' 
      });
    }
  }, [userId]);

  useEffect(() => {
    if (userId) {
      fetchUser();
    }
  }, [userId, fetchUser]);

  return {
    ...state,
    refetch: fetchUser
  };
};

// Good: Proper dependency arrays
useEffect(() => {
  const interval = setInterval(fetchData, 5000);
  return () => clearInterval(interval);
}, [fetchData]); // fetchData should be wrapped in useCallback
```

### State Management with Zustand
```typescript
// Good: Zustand store with proper typing
interface AuthStore {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  updateUser: (user: User) => void;
}

export const useAuthStore = create<AuthStore>((set, get) => ({
  user: null,
  token: null,
  isAuthenticated: false,

  login: async (credentials) => {
    try {
      const { user, token } = await authService.login(credentials);
      set({ user, token, isAuthenticated: true });
      localStorage.setItem('token', token);
    } catch (error) {
      throw new Error('Login failed');
    }
  },

  logout: () => {
    set({ user: null, token: null, isAuthenticated: false });
    localStorage.removeItem('token');
  },

  updateUser: (user) => {
    set({ user });
  }
}));
```

## OpenAPI Integration

### Code Generation
```typescript
// Generated types from OpenAPI spec
export interface StockQuote {
  symbol: string;
  price: number;
  change: number;
  changePercent: number;
  volume: number;
  marketCap: number;
  lastUpdated: string;
}

export interface GetStockQuoteRequest {
  symbol: string;
}

export interface GetStockQuoteResponse {
  data: StockQuote;
  success: boolean;
  message?: string;
}

// Generated API client
export const stockApi = {
  getQuote: async (request: GetStockQuoteRequest): Promise<GetStockQuoteResponse> => {
    const response = await fetch(`/api/stocks/${request.symbol}/quote`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${getToken()}`
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return response.json();
  }
};
```

## Component Testing

### Unit Tests with React Testing Library
```typescript
// Good: Comprehensive component testing
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { UserProfile } from './UserProfile';
import { userService } from '../services/userService';

// Mock the service
jest.mock('../services/userService');
const mockUserService = userService as jest.Mocked<typeof userService>;

describe('UserProfile', () => {
  const mockUser: User = {
    id: 1,
    username: 'testuser',
    email: 'test@example.com',
    role: 'user',
    createdAt: new Date()
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders user information correctly', async () => {
    mockUserService.getUser.mockResolvedValue(mockUser);

    render(<UserProfile userId={1} />);

    await waitFor(() => {
      expect(screen.getByText('testuser')).toBeInTheDocument();
      expect(screen.getByText('test@example.com')).toBeInTheDocument();
    });
  });

  it('handles edit action', async () => {
    const onEdit = jest.fn();
    mockUserService.getUser.mockResolvedValue(mockUser);

    render(<UserProfile userId={1} onEdit={onEdit} />);

    await waitFor(() => {
      expect(screen.getByText('Edit')).toBeInTheDocument();
    });

    fireEvent.click(screen.getByText('Edit'));
    expect(onEdit).toHaveBeenCalledWith(mockUser);
  });

  it('displays error message on fetch failure', async () => {
    mockUserService.getUser.mockRejectedValue(new Error('User not found'));

    render(<UserProfile userId={1} />);

    await waitFor(() => {
      expect(screen.getByText('User not found')).toBeInTheDocument();
    });
  });

  it('shows loading state initially', () => {
    mockUserService.getUser.mockImplementation(() => new Promise(() => {}));

    render(<UserProfile userId={1} />);

    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();
  });
});
```

## Definition of Done for Frontend Components
- [ ] OpenAPI types generated and integrated
- [ ] Component implemented with proper TypeScript typing
- [ ] Responsive design implemented
- [ ] Accessibility requirements met (ARIA, semantic HTML)
- [ ] 100% passing unit tests for component logic
- [ ] Integration tests passing
- [ ] Performance optimized (memoization, lazy loading)
- [ ] Error handling implemented
- [ ] Loading states implemented
- [ ] Code reviewed and approved
- [ ] Accessibility audit completed
- [ ] Performance benchmarks met